# Пояснення математичних операцій в обробниках спелів

## 1. **Math.random() * 100** - Генерація випадкового числа для перевірки шансів

**Де використовується:**
- Перевірка уклону (evasion): `Math.random() * 100 < opponentAbilities.evasion`
- Перевірка критичного удару: `Math.random() * 100 < ability.coef`
- Перевірка контратаки: `Math.random() * 100 < opponentAbilities.contrAttack`

**Що робить:**
- `Math.random()` повертає випадкове число від 0.0 до 0.999...
- Множення на 100 дає число від 0 до 99.999...
- Це дозволяє порівнювати з відсотками (наприклад, 35% = 35)

**Приклад:**
```javascript
// Якщо evasion = 35, то:
// Math.random() * 100 може бути 0-99.99
// Якщо результат < 35, то уклон спрацював (35% шанс)
if (Math.random() * 100 < 35) {
    // Уклон спрацював!
}
```

---

## 2. **Math.floor()** - Округлення вниз до цілого числа

**Де використовується:**
- Розрахунок зменшення урону через def-piece
- Розрахунок відбитого урону через spikes
- Розрахунок урону контратаки
- Застосування коефіцієнта для bishop-shoot

**Що робить:**
- Округлює число вниз до найближчого цілого
- Потрібно, бо урон має бути цілим числом

**Приклади:**
```javascript
// Приклад 1: Зменшення урону на 60%
finalDamage = 50
dmg_def = 60
// 50 * (1 - 60/100) = 50 * 0.4 = 20.0
Math.floor(50 * (1 - 60/100)) = Math.floor(20.0) = 20

// Приклад 2: Відбиття 45% урону
finalDamage = 30
spikes = 45
// 30 * (45/100) = 30 * 0.45 = 13.5
Math.floor(30 * (45/100)) = Math.floor(13.5) = 13
```

**Чому важливо:**
- Без `Math.floor()` можуть виникнути дробові значення (наприклад, 13.7 HP)
- У грі HP має бути цілим числом

---

## 3. **finalDamage * (1 - defAbility.dmg_def / 100)** - Зменшення урону через захист

**Де використовується:**
- В усіх атаках, коли активований def-piece

**Що робить:**
- `dmg_def / 100` - перетворює відсоток у десятковий дріб (60% → 0.6)
- `1 - ...` - знаходить залишок після зменшення (1 - 0.6 = 0.4)
- Множення на `finalDamage` - застосовує зменшення до урону

**Приклад:**
```javascript
finalDamage = 50
dmg_def = 60  // 60% зменшення

// Крок 1: 60 / 100 = 0.6 (60% у десятковому вигляді)
// Крок 2: 1 - 0.6 = 0.4 (залишається 40% урону)
// Крок 3: 50 * 0.4 = 20 (фінальний урон)

// Результат: замість 50 урону, супротивник отримає 20 урону
```

**Математична формула:**
```
Новий урон = Старий урон × (1 - Відсоток_зменшення / 100)
```

---

## 4. **finalDamage * (opponentAbilities.spikes / 100)** - Відбиття урону через spikes

**Де використовується:**
- В усіх атаках, коли активований spikes

**Що робить:**
- `spikes / 100` - перетворює відсоток у десятковий дріб (45% → 0.45)
- Множення на `finalDamage` - обчислює скільки урону відбивається назад

**Приклад:**
```javascript
finalDamage = 40
spikes = 45  // 45% відбиття

// 40 * (45/100) = 40 * 0.45 = 18
// Атакуючий отримає 18 урону назад
```

**Логіка:**
- Супротивник отримує `finalDamage` урону
- Атакуючий отримує `reflectedDamage` урону назад
- Це створює ризик для атакуючого

---

## 5. **damage * (opponentAbilities.contrAttackCoef / 100)** - Урон контратаки

**Де використовується:**
- Коли спрацьовує контратака після атаки супротивника

**Що робить:**
- `contrAttackCoef / 100` - перетворює відсоток у десятковий дріб (45% → 0.45)
- Множення на `damage` - обчислює урон контратаки від оригінального урону

**Приклад:**
```javascript
damage = 30  // Оригінальний урон атаки
contrAttackCoef = 45  // 45% від оригінального урону

// 30 * (45/100) = 30 * 0.45 = 13.5
// Math.floor(13.5) = 13
// Атакуючий отримає 13 урону від контратаки
```

**Важливо:**
- Контратака обчислюється від **оригінального** урону (`damage`), а не від `finalDamage`
- Це означає, що навіть якщо урон був зменшений через def-piece, контратака все одно наноситься від повного урону

---

## 6. **Math.max(0, hp - damage)** - Застосування урону з перевіркою мінімуму

**Де використовується:**
- В усіх місцях, де застосовується урон до HP

**Що робить:**
- `hp - damage` - віднімає урон від поточного HP
- `Math.max(0, ...)` - гарантує, що HP не стане від'ємним

**Приклад:**
```javascript
hpW = 10
damage = 15

// Без Math.max:
hpW = 10 - 15 = -5  // ❌ Неможливо, HP не може бути від'ємним

// З Math.max:
hpW = Math.max(0, 10 - 15) = Math.max(0, -5) = 0  // ✅ HP = 0
```

**Чому важливо:**
- Запобігає від'ємним значенням HP
- Коли HP досягає 0, фігура вважається мертвою

---

## 7. **Math.min(maxHp, hp + heal)** - Застосування лікування з перевіркою максимуму

**Де використовується:**
- В healing-send та vampiring-send

**Що робить:**
- `hp + heal` - додає лікування до поточного HP
- `Math.min(maxHp, ...)` - гарантує, що HP не перевищить максимум

**Приклад:**
```javascript
hpW = 100
maxHp = 130
heal = 50

// Без Math.min:
hpW = 100 + 50 = 150  // ❌ Перевищує максимум 130

// З Math.min:
hpW = Math.min(130, 100 + 50) = Math.min(130, 150) = 130  // ✅ HP = 130 (максимум)
```

**Чому важливо:**
- Запобігає перевищенню максимального HP
- Кожна фігура має своє максимальне HP (наприклад, король = 200, пішак = 75)

---

## 8. **damage * playerAbilities.stacks** - Множення урону на стаки (Knight)

**Де використовується:**
- В kamicadze-send для Knight

**Що робить:**
- Множить базовий урон на кількість накопичених стаків
- Кожен стак збільшує урон

**Приклад:**
```javascript
damage = 15  // Базовий урон
stacks = 3   // Накопичені стаки

// 15 * 3 = 45
// Замість 15 урону, буде нанесено 45 урону
```

**Логіка:**
- Knight може накопичувати до 5 стаків
- Після використання стаки скидаються до 1

---

## 9. **(opponentHp / opponentMaxHp) * 100** - Обчислення відсотка HP

**Де використовується:**
- В prayers-send для перевірки, чи HP супротивника < 15%

**Що робить:**
- `opponentHp / opponentMaxHp` - знаходить частку поточного HP від максимуму (0.0 до 1.0)
- Множення на 100 - перетворює в відсотки (0% до 100%)

**Приклад:**
```javascript
opponentHp = 20
opponentMaxHp = 200

// Крок 1: 20 / 200 = 0.1 (10% від максимуму)
// Крок 2: 0.1 * 100 = 10 (10%)

// Якщо opponentHpPercent < 15, то супротивник вбивається
// 10 < 15 → true → супротивник вбивається
```

**Логіка:**
- Якщо супротивник має менше 15% HP, prayers вбиває його миттєво
- Інакше, гравець отримує 40 урону сам

---

## 10. **abilities.stacks++** - Інкремент стаків

**Де використовується:**
- В stacking-send

**Що робить:**
- Збільшує кількість стаків на 1
- Еквівалентно `abilities.stacks = abilities.stacks + 1`

**Приклад:**
```javascript
abilities.stacks = 2
abilities.stacks++  // Тепер abilities.stacks = 3
```

**Обмеження:**
- Стаки не можуть перевищити `max_stacks` (5)
- Перевірка: `if (abilities.stacks < ability.max_stacks)`

---

## 11. **damage * (ability.coef / 100)** - Застосування коефіцієнта для bishop-shoot

**Де використовується:**
- В bishop-shoot-send

**Що робить:**
- Зменшує урон до певного відсотка (наприклад, 45%)
- Bishop-shoot ігнорує щити, але все одно застосовує коефіцієнт

**Приклад:**
```javascript
damage = 30
coef = 45  // 45%

// 30 * (45/100) = 30 * 0.45 = 13.5
// Math.floor(13.5) = 13
// Фінальний урон = 13
```

**Логіка:**
- Bishop-shoot ігнорує evasion та def-piece
- Але застосовує коефіцієнт, тому урон все одно зменшується

---

## 12. **Порядок обчислень урону (важливо!)**

При атаці урон обчислюється в такому порядку:

1. **Базовий урон** → `damage = ability.damage`
2. **Критичний удар** (якщо є) → `damage = ability.dmg_coef` (30% шанс)
3. **Множення на стаки** (якщо є) → `damage = damage * stacks`
4. **Перевірка уклону** → якщо спрацював, `finalDamage = 0`
5. **Застосування def-piece** → `finalDamage = finalDamage * (1 - 60/100)`
6. **Відбиття spikes** → `reflectedDamage = finalDamage * (spikes/100)`
7. **Застосування урону** → `hp = Math.max(0, hp - finalDamage)`
8. **Контратака** (якщо спрацювала) → `counterDamage = damage * (coef/100)`

**Важливо:**
- Контратака обчислюється від **оригінального** `damage`, а не від `finalDamage`
- Spikes відбиває `finalDamage` (після def-piece)
- Def-piece застосовується до `finalDamage` (після уклону)

---

## Підсумок всіх операцій:

| Операція | Призначення | Приклад |
|----------|-------------|---------|
| `Math.random() * 100` | Генерація шансу (0-100) | Перевірка уклону 35% |
| `Math.floor()` | Округлення вниз | 13.7 → 13 |
| `* (1 - X/100)` | Зменшення на X% | 50 * 0.4 = 20 (зменшення на 60%) |
| `* (X/100)` | Відсоток від числа | 40 * 0.45 = 18 (45% від 40) |
| `Math.max(0, x)` | Мінімум 0 | Math.max(0, -5) = 0 |
| `Math.min(max, x)` | Максимум max | Math.min(130, 150) = 130 |
| `x++` | Збільшення на 1 | 2++ = 3 |
| `x * y` | Множення | 15 * 3 = 45 |
| `(x / y) * 100` | Відсоток | (20/200)*100 = 10% |

